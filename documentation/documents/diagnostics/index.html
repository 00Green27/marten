<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8"> 
        <meta charset="utf-8">
        <meta name="generator" content="Bootply" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		<title>Marten - Diagnostics and Instrumentation</title>
		<link href="/marten/content/bootstrap.min.css" rel="stylesheet" type="text/css" />
		<link href="/marten/content/prism.css" rel="stylesheet" type="text/css" />
		<link href="/marten/content/theme.css" rel="stylesheet" type="text/css" />
		<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" />
        

        <link rel="apple-touch-icon" href="/bootstrap/img/apple-touch-icon.png">
        <link rel="apple-touch-icon" sizes="72x72" href="/bootstrap/img/apple-touch-icon-72x72.png">
        <link rel="apple-touch-icon" sizes="114x114" href="/bootstrap/img/apple-touch-icon-114x114.png">


        <!-- CSS code from Bootply.com editor -->
        <link href="/marten/content/affix.css" rel="stylesheet" type="text/css" />
    </head>
    
    <!-- HTML code from Bootply.com editor -->
    
    <body  >

<a href="https://github.com/jasperfx/marten"><img style="z-index: 5000; position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
        
        <nav class="navbar navbar-default navbar-fixed-top" role="banner">
		  <div class="container">
		    <div class="navbar-header">
		      <a href="/marten" class="navbar-brand">Marten</a>
		    </div>
		    <nav class="collapse navbar-collapse" role="navigation">
		      <ul class="nav navbar-nav pull-right">
            <li>
              <a href="/marten/getting_started">Getting Started</a>
            </li>
		        <li>
		          <a href="/marten/documentation">Documentation</a>
		        </li>
		        <li>
<a href="https://gitter.im/jasperfx/marten?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/jasperfx/marten" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a>
		        </li>
		      	<li><a href="/marten/documentation/documents/advanced" title="Advanced Topics">Previous</a></li>
		      	<li><a href="/marten/documentation/events" title="Marten as Event Store">Next</a></li>
		      </ul>
      <div class="navbar-form navbar-left" role="search">
        <div class="form-group">
          <input id="search" type="search" class="form-control" placeholder="Search">
        </div>
      </div>

		    </nav>

		  </div>
		</nav>

		  <div class="container">
		  	<nav class="navbar-inverse">
		  		<ol class="breadcrumb"><li><a href="/marten/">Marten</a></li><li><a href="/marten/documentation">Documentation</a></li><li><a href="/marten/documentation/documents">Marten as Document Db</a></li><li class="active">Diagnostics and Instrumentation</li></ol>
		  	</nav>
		  </div>

		<!--main-->
		<div class="container">
			<div class="row">
		      <!--left-->
		      
		      <div class="col-md-3" id="leftCol">
		      	<h3>Marten 1.0-alpha</h3>
		      	<br />

				<ul class="nav nav-stacked affix" id="sidebar">

		        </ul>

		        	<h3 class="no-margin">Next</h3><p><a href="/marten/documentation/events">Marten as Event Store</a></p>
		        	<h3 class="no-margin">Previous</h3><a href="/marten/documentation/documents/advanced">Advanced Topics</a></p>

		        </ul>
		      </div><!--/left-->
		      
		      <!--right-->
		      <div class="col-md-9">
			      	<h1>Diagnostics and Instrumentation <a href="https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/diagnostics.md"  class="text-muted small pull-right fa fa-github" style="margin-top: 10px"> Edit on GitHub</a></h1>
			      
			      	<hr />

			      	<div id="main-pane">
			      		<!--Title:Diagnostics and Instrumentation-->
<!--Url:diagnostics-->
<p>So far, Marten has diagnostics, command logging, and unit of work lifecycle tracking.</p>
<p>For information on accessing and previewing the database schema objects generated by Marten, see <a href="/marten/documentation/schema">Marten and the Postgresql Schema</a></p>
<h2>Listening for Document Store Events</h2>
<p><strong>All of the functionality in this section was added as part of Marten v0.8</strong></p>
<p>Marten has a facility for listening and even intercepting document persistence events with the <code>IDocumentSessionListener</code> interface:</p>
<pre><code class="language-csharp">
    public interface IDocumentSessionListener
    {
        /// &lt;summary&gt;
        /// Called just after IDocumentSession.SaveChanges() is called, but before
        /// any database calls are made
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;session&quot;&gt;&lt;/param&gt;
        void BeforeSaveChanges(IDocumentSession session);

        /// &lt;summary&gt;
        /// Called just after IDocumentSession.SaveChanges() is called,
        /// but before any database calls are made
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;session&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;token&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        Task BeforeSaveChangesAsync(IDocumentSession session, CancellationToken token);


        /// &lt;summary&gt;
        /// After an IDocumentSession is committed
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;session&quot;&gt;&lt;/param&gt;
        void AfterCommit(IDocumentSession session);

        /// &lt;summary&gt;
        /// After an IDocumentSession is committed
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;session&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;token&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        Task AfterCommitAsync(IDocumentSession session, CancellationToken token);


        /// &lt;summary&gt;
        /// Called after a document is loaded
        /// &lt;/summary&gt;
        void DocumentLoaded(object id, object document);

        /// &lt;summary&gt;
        /// Called after a document is explicitly added to a session
        /// as a staged insert or update
        /// &lt;/summary&gt;
        void DocumentAddedForStorage(object id, object document);
    }
</code></pre>
<p>You can build and inject your own listeners by adding them to the <code>StoreOptions</code> object you use to configure a <code>DocumentStore</code>:</p>
<pre><code class="language-csharp">
            var stub1 = new StubDocumentSessionListener();
            var stub2 = new StubDocumentSessionListener();

            using (var store = DocumentStore.For(_ =&gt;
            {
                _.Connection(ConnectionSource.ConnectionString);
                _.AutoCreateSchemaObjects = AutoCreate.All;

                _.Listeners.Add(stub1);
                _.Listeners.Add(stub2);
            }))
</code></pre>
<p>The listeners can be used to modify an <code>IDocumentSession</code> and its related unit of work just before persisting. Marten itself will be using this mechanism
internally to perform projections in the future.</p>
<p>The following fake, sample listener demonstrates how you can query into the pending changes before making a transactional commit, and also how to
query what was done after a commit is made:</p>
<pre><code class="language-csharp">
    // DocumentSessionListenerBase is a helper abstract class in Marten
    // with empty implementations of each method you may find helpful
    public class SimpleSessionListener : DocumentSessionListenerBase
    {
        public override void BeforeSaveChanges(IDocumentSession session)
        {
            // Use pending changes to preview what is about to be
            // persisted
            var pending = session.PendingChanges;

            // Careful here, Marten can only sort documents into &quot;inserts&quot; or &quot;updates&quot; based
            // on whether or not Marten had to assign a new Id to that document upon DocumentStore()
            pending.InsertsFor&lt;User&gt;()
                .Each(user =&gt; Debug.WriteLine($&quot;New user: {user.UserName}&quot;));

            pending.UpdatesFor&lt;User&gt;()
                .Each(user =&gt; Debug.WriteLine($&quot;Updated user {user.UserName}&quot;));

            pending.DeletionsFor&lt;User&gt;()
                .Each(d =&gt; Debug.WriteLine(d));

            // This is a convenience method to find all the pending events
            // organized into streams that will be appended to the event store
            pending.Streams()
                .Each(s =&gt; Debug.WriteLine(s));
        }

        public override void AfterCommit(IDocumentSession session)
        {
            // See what was just persisted, and possibly carry out post
            // commit actions

            var last = session.LastCommit;

            last.Updated.Each(x =&gt; Debug.WriteLine($&quot;{x} was updated&quot;));
            last.Deleted.Each(x =&gt; Debug.WriteLine($&quot;{x} was deleted&quot;));
            last.Inserted.Each(x =&gt; Debug.WriteLine($&quot;{x} was inserted&quot;));
        }
    }

</code></pre>
<h2>Custom Logging</h2>
<p>Marten v0.8 comes with a new mechanism to plug in custom logging to the <code>IDocumentStore</code>, <code>IQuerySession</code>, and <code>IDocumentSession</code> activity:</p>
<pre><code class="language-csharp">
    /// &lt;summary&gt;
    /// Records command usage, schema changes, and sessions within Marten
    /// &lt;/summary&gt;
    public interface IMartenLogger
    {
        IMartenSessionLogger StartSession(IQuerySession session);

        void SchemaChange(string sql);
    }

    /// &lt;summary&gt;
    /// Use to create custom logging within an IQuerySession or IDocumentSession
    /// &lt;/summary&gt;
    public interface IMartenSessionLogger
    {
        /// &lt;summary&gt;
        /// Log a command that executed successfully
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;command&quot;&gt;&lt;/param&gt;
        void LogSuccess(NpgsqlCommand command);

        /// &lt;summary&gt;
        /// Log a command that failed
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;command&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;ex&quot;&gt;&lt;/param&gt;
        void LogFailure(NpgsqlCommand command, Exception ex);

        /// &lt;summary&gt;
        /// Called immediately after committing an IDocumentSession
        /// through SaveChanges() or SaveChangesAsync()
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;session&quot;&gt;&lt;/param&gt;
        void RecordSavedChanges(IDocumentSession session);
    }
</code></pre>
<p>To apply these logging abstractions, you can either plug your own <code>IMartenLogger</code> into the <code>StoreOptions</code> object and allow that default logger to create the individual session loggers:</p>
<pre><code class="language-csharp">
            var store = DocumentStore.For(_ =&gt;
            {
                _.Logger(new ConsoleMartenLogger());
            });
</code></pre>
<p>You can also directly apply a session logger to any <code>IQuerySession</code> or <code>IDocumentSession</code> like this:</p>
<pre><code class="language-csharp">
            using (var session = store.OpenSession())
            {
                // Replace the logger for only this one session
                session.Logger = new RecordingLogger();
            }
</code></pre>
<p>The session logging is a different abstraction specifically so that you <em>could</em> track database commands issued per session. In effect, my own shop is going to use this capability to understand what HTTP endpoints or service bus message handlers are being unnecessarily chatty in their database interactions. We also hope that the contextual logging of commands per document session makes it easier to understand how our systems behave.</p>
<pre><code class="language-csharp">
    public class ConsoleMartenLogger : IMartenLogger, IMartenSessionLogger
    {
        public IMartenSessionLogger StartSession(IQuerySession session)
        {
            return this;
        }

        public void SchemaChange(string sql)
        {
            Console.WriteLine(&quot;Executing DDL change:&quot;);
            Console.WriteLine(sql);
            Console.WriteLine();
        }

        public void LogSuccess(NpgsqlCommand command)
        {
            Console.WriteLine(command.CommandText);
        }

        public void LogFailure(NpgsqlCommand command, Exception ex)
        {
            Console.WriteLine(&quot;Postgresql command failed!&quot;);
            Console.WriteLine(command.CommandText);
            Console.WriteLine(ex);
        }

        public void RecordSavedChanges(IDocumentSession session)
        {
            var lastCommit = session.LastCommit;
            Console.WriteLine(
                $&quot;Persisted {lastCommit.Updated.Count()} updates, {lastCommit.Inserted.Count()} inserts, and {lastCommit.Deleted.Count()} deletions&quot;);
        }
    }
</code></pre>
<h2>Accessing Diagnostics</h2>
<p>All the diagnostics are going to be exposed off of the <code>IDocumentStore.Diagnostics</code> property. Today, the only capabilities are to get a preview of the generated storage code or a preview of the ADO.Net code that will be generated for a Linq query.</p>
<h2>Previewing Linq Queries</h2>
<p>Let's say that we have a small document type called <code>Trade</code>:</p>
<pre><code class="language-csharp">
    public class Trade
    {
        public int Id { get; set; }

        [DuplicateField]
        public double Value { get; set; }
    }

</code></pre>
<p>The <code>[Searchable]</code> attribute directs Marten to duplicate the value of <code>Value</code> into a separate database field for more efficient querying. Now, let's say that we want to search for every <code>Trade</code> document with a value of over 2,000, but we want to see the SQL query that Marten will build for that query first:</p>
<pre><code class="language-csharp">
            // store is the active IDocumentStore
            var queryable = store.QuerySession().Query&lt;Trade&gt;().Where(x =&gt; x.Value &gt; 2000);
            var cmd = queryable.ToCommand(FetchType.FetchMany);

            Debug.WriteLine(cmd.CommandText);
</code></pre>
<p>The sql string in our debug window for the code above is:</p>
<pre>
select d.data from mt_doc_trade as d where d.value > :arg0
</pre>
<h2>Previewing the Postgresql Query Plan</h2>
<p>Marten has a helper to find and preview the <a href="http://www.postgresql.org/docs/9.5/static/using-explain.html">Postgresql EXPLAIN plan</a> for a Linq query. Our hope is that this will be a valuable aid to teams who need face performance problems while using Marten. The syntax for fetching the EXPLAIN plan for the Linq query from the previous section is shown below:</p>
<pre><code class="language-csharp">
            // Explain() is an extension method off of IQueryable&lt;T&gt;
            var plan = queryable.Explain();
            Console.WriteLine($&quot;NodeType: {plan.NodeType}&quot;);
            Console.WriteLine($&quot;RelationName: {plan.RelationName}&quot;);
            Console.WriteLine($&quot;Alias: {plan.Alias}&quot;);
            Console.WriteLine($&quot;StartupCost: {plan.StartupCost}&quot;);
            Console.WriteLine($&quot;TotalCost: {plan.TotalCost}&quot;);
            Console.WriteLine($&quot;PlanRows: {plan.PlanRows}&quot;);
            Console.WriteLine($&quot;PlanWidth: {plan.PlanWidth}&quot;);
</code></pre>
<p>The console output for the code below (on my box) was:</p>
<pre>
NodeType: Seq Scan
RelationName: mt_doc_trade
Alias: d
StartupCost: 0
TotalCost: 24.13
PlanRows: 377
PlanWidth: 36
</pre>
<h2>Request Counting and Thresholds</h2>
<p>Marten has several facilities for improving system performance by reducing the number of network round trips to the server, but the first step maybe to
just understand what kinds of operations are being chatty in the first place. To that end, Marten exposes the request count for each <code>IQuerySession</code> or <code>IDocumentSession</code> that simply tells you how many commands have been issued to Postgresql by that session:</p>
<pre><code class="language-csharp">
            using (var session = store.QuerySession())
            {
                var users = session.Query&lt;User&gt;().ToList();
                var count = session.Query&lt;User&gt;().Count();
                var any = session.Query&lt;User&gt;().Any();

                session.RequestCount.ShouldBe(3);
            }
</code></pre>
<p>At this point, Marten does not have any built in support for asserting requests per session thresholds like other tools. While I think that we are uncomfortable with that functionality ever being turned on in production, it should be easily feasible to build those kinds of automated threshold testing like &quot;fail the test if there were more than 25 requests issued for any given HTTP request.&quot;</p>


			      	</div>

			      	<hr />

			      	<nav>
				        <span>
				        	<strong>Previous: </strong><a href="/marten/documentation/documents/advanced">Advanced Topics</a>

				        </span>
				        <span class="pull-right">

				        	<strong>Next: </strong><a href="/marten/documentation/events">Marten as Event Store</a>

				        </span>
			      	</nav>

		      </div><!--/right-->
		  	</div><!--/row-->
		</div><!--/container-->


    </body>


    <foot>
        <script type='text/javascript' src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
        <script type='text/javascript' src="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>

        <script type="text/javascript" src="/marten/content/embed.js"></script>
        <script type="text/javascript" src="/marten/content/prism.js"></script>
        <script type="text/javascript" src="/marten/content/sidebar.js"></script>
        <script type="text/javascript" src="/marten/content/affix.js"></script>

<script>
$('#search').keyup(function(e){
  if(e.keyCode == 13) {
    var search = $('#search').val();

    var url = 'https://www.google.com/#q=site:jasperfx.github.io ' + search;
    url = encodeURI(url);

    //alert(url);

    window.location.href = url;

    e.stopPropagation();
    if (e.cancelBubble!=null) e.cancelBubble = true;
    return false;
  }



}); 

</script>
    </foot>
</html>

